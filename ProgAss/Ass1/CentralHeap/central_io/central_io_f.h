#ifndef CENTRAL_IO_F
#define CENTRAL_IO_F

#include "central_io.h"
// #include <string>
using namespace std;
/* READ2HEAP
 * INPUT == NULL
 * OUTPUT == NULL
 * EFFECT
 * 1. It reads registrations from files generated by local registries, convert them into fibnodes and then insert all nodes into the fibheap
 * Algorithm Description
 * While inserting, it does the following things:
 * 1. Before insert, check if the ID is in hash table of the central heap (Check *withdrawn*, *centralheap*, *assigned*), if the id is not in hashtable, directly insert this node into the heap
 * if the node is in any of the three hash table, execute helper functions corresponding to the three cases.
 * 2. 
 * 3. 



 */
CentralIO::CentralIO(FibHeap* heap, string path, Assignment* assignment){
    CentralIO::heap = heap;
    CentralIO::path = path;
    CentralIO::assignment = assignment;
};

bool CentralIO::Read2Heap(){
    ifstream infile;
    infile.open(path, ifstream::in);

    // wait for information from local registries
    if (infile.eof()){
        infile.close();
        return false;
    }

    if (infile.fail()) { 
        cout << "File not found" <<endl; 
        return false;
    }
    vector<string> temp_list;
    string temp;
    string line;   
    getline(infile, line);  // remove the title of the CSV file
    while (true){
            getline(infile, line);
            
            // terminate the reading process on encountering an empty line
            if (int(line.size()) == 0) break; 
            
            // reading registrations from files generated from local registries
            for (int i = 0; i < int(line.size()); i++) {
                if (line.substr(i,1) == ",") {
                    // put this string into the vector
                    temp_list.push_back(temp);
                    // clear the temp string for the next argument
                    temp.clear();
                    continue;
                }
                if (line.substr(i,1) == "\r") {
                    continue;
                }
                temp.append(line.substr(i,1));
            }
            temp_list.push_back(temp);
            temp.clear();
        // clear this list for next use
        FibNode* newnode = new FibNode(temp_list);
        temp_list.clear();
        //check hash set
        if (newnode->getwithdraw()) {
            if (newnode->getwithdraw() == 1){
                /*
                * 1. remove the node from hash table
                * 2. remove the node from the heap
                * 3. insert the new node into the withdraw_table
                * 4. remove the node from ddl queue (if the node was in that queue)
                * 5. release memory occupied by the old node
                */
                FibNode* old = NULL;
                heap->withdraw_table_insert(newnode);

                if (heap->hash_intable_check(newnode->getid())){
                    old = heap->hash_table_remove(newnode->getid());
                    heap->Delete(old);
                    
                } else if (heap->highrisk_intable_check(newnode->getid())){
                    old = heap->highrisk_table_remove(newnode->getid());
                    heap->highrisk_queue->Delete(old);
                } else if (heap->assigned_intable_check(newnode->getid())) {
                    // all above branches leave the case where the node is already assigned and not in any heaps
                    old = heap->assigned_table_find(newnode->getid());
                    Appointment* app = old->getAppointment();       // TODO, rewrite all function related to APPOINTMENT needed here
                    // if the patient has already been assigned remove the appointment
                    if (app) app->loc->removeAppointment(app);
                    heap->assigned_table_remove(old->getid());
                    delete app;
                }

                    // if the node was in the DDL queue, remove the node from the queue
                
                if (old && heap->ddl_incheck(old)){
                    heap->ddl_delete(old);      //TODO Bug here may not exist in the ddl queue
                // insert the new one in case of any update
                // heap->withdraw_table_insert(newnode);
                }
                 
                if (old) delete old; 
                // withdraw == 1 (this indicates a withdraw has been prompted, we have to search this node in the hashtable and move the node from the heap to the withdrawn set, set withdraw = 2) 
                // put this node into the withdrawn hashset 
            } else {
                // withdraw == 2 (this indicates the node now needs an re-insertion into the heap with a 14-day extension )
                /*
                * 1. remove the node from withdraw_table
                * 2. add the node into hash_table
                * 3. insert the node into the heap
                * 4. if ddl, add this node into the ordered list of ddl
                */

                heap->withdraw_table_remove(newnode->getid());
                if (newnode->getrisk() == 3){
                    heap->highrisk_table_insert(newnode);
                    heap->highrisk_queue->Insert(newnode);
                } else {
                    heap->hash_table_insert(newnode);
                    heap->Insert(newnode);
                }

                if (newnode->getddl() != -1) {
                    heap->ddl_insert(newnode);
                }
            }

        // the part for update

        } else if (heap->hash_intable_check(newnode->getid())){
            if (newnode->getrisk() == Risk (3)) {
                cout << "You are FUCKED up by the local queue\n";
                cout << "FUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUCK at you? CentralIO line 137\n";
            }
            // the node is in hashtable
            //invoke the swap function
            /*
            * 1. swap the two node in the hash table
            * 2. swap the two node in the fibonacci 
            */
            FibNode* old;
            old = heap->hash_table_swap(newnode); 
            // delete the older version of the previous registration

            heap->Delete(old);
            heap->Insert(newnode);  // TODO Actually I can invoke a decrease key function here

            // do ddl update (if necessary)
            if (old->getddl() != -1){
                heap->ddl_delete(old);
            }
            if (newnode->getddl() != -1){
                heap->ddl_insert(newnode);
            }
            delete old;
            // do node swap and delete the original node

            // but there are several cases to consider:
            // 1. the element is also in the ddl queues
        } else if (heap->highrisk_intable_check(newnode->getid())){
            
            FibNode* old;
            old = heap->highrisk_table->retrieval(newnode->getid()); 
            heap->highrisk_table_remove(newnode->getid());
            heap->highrisk_queue->Delete(old);

            if (newnode->getrisk() == 3) {
                heap->highrisk_table_insert(newnode);
                heap->highrisk_queue->Insert(newnode);
            } else { 
                heap->hash_table_insert(newnode);
                heap->Insert(newnode);
            }
            // do ddl update (if necessary)
            if (old->getddl() != -1) {
                heap->ddl_delete(old);
            }
            if (newnode->getddl() != -1) {
                heap->ddl_insert(newnode);
            }
            delete old;

            // if (heap->highrisk_intable_check(newnode->getid())){
            //     // in case of an update
            //     heap->highrisk_table_remove(newnode->getid());
            //     heap->highrisk_table_insert(newnode);
            // } else {
            // // if high risk encountered
            // heap->highrisk_table_insert(newnode);
            // heap->highrisk_queue->Insert(newnode);
            
        } else {
            // do normal insertion
            if (newnode->getrisk() == 3) {
                heap->highrisk_queue->Insert(newnode);
                heap->highrisk_table_insert(newnode);
            } else {
                heap->Insert(newnode);
                heap->hash_table_insert(newnode);
            }
        }
        
        if (newnode->getddl() != -1) {
            heap->ddl_insert(newnode);
            assignment->_assign(newnode, newnode->getddl() - 1);
        }    
    }
    return true;
}
/* CentralIO::Write2File
 * INPUT
 * 1. print_list -- a vector of registrations to be printed
 * 2. date       -- the date when a Write2File function is invoked (this affects the name of files)
 * 3. type       -- indicates the type of print (cured, assigned, waiting)
 * OUTPUT
 * 1. true/false -- whether the report generation has succeeded
 */

bool CentralIO::Write2File(vector<FibNode*>&print_list, int date, int type) {
    string filename = "Report_";
    if (type == 3) {
        filename += "Month_" + to_string(date / 30 + 1);
    } else {
        filename += "Week_" + to_string(date / 7 + 1);
    }

    switch (type) {
        case 0:
        filename = "Report_Week_" + to_string(date / 7 + 1) + "_Cured.csv";
        break;

        case 1:
        filename = "Report_Week_" + to_string(date / 7 + 1) + "_Assigned.csv";
        break;

        case 2:
        filename = "Report_Week_" + to_string(date / 7 + 1) + "_Waiting.csv";
        break;

        case 3:
        filename = "Report_Month_" + to_string(date / 30 + 1) + ".csv";

        default:
        cout << "You are fucked at CentralIO::Write2File" << date << type << endl;
        exit(3);
    }   

    ofstream out("output/"+ filename);
    out << "ProfessionCategory,AgeCategory,RiskStatus,WaitingTime";
    for (int i = 0; i < int(print_list.size()); i++) {
        out << print_list[i]->getpro();
        out << ",";
        out << print_list[i]->getage();
        out << ",";
        out << print_list[i]->getrisk();
        out << ",";
        if (type == 0)
            out << print_list[i]->getAppointment()->getDate() - print_list[i]->getdate() << endl;
        else
            out << date - print_list[i]->getdate();
    }
    out.close();
    return true;
}


/* TODO <=== Helper Function for Generating Reports ===> */
bool CentralIO::ReportWeekly(int week, int key){
    /* Generate Weekly Report for 
     * 1. People who have been treated including their profession, age category, risk status, and the waiting time from registration to treatment
     * 2. the registered people with a set appointment including their profession category, age category, risk status and their waiting time until now
     * 3. the queueing people without a set appointment including their profession category, age category, risk status and their waiting time until now
     */
    _WeeklyCured(week, key);
    _WeeklyAssigned(week, key);
    _WeeklyQueueing(week, key);
    return true;
}




bool CentralIO::ReportMonthly(int month, int key){
    _Monthly(month, key);
    return true;
}


/*
 * INPUT
 * OUTPUT
 * 1. Whether the report generation has succeed or not
 * EFFECT
 *      This function will take all information to be printed 
 *      from *assignment->all_locations->cured_list*. And call 
 *      CentralIO::sortByKey() to sort the vector w.r.t the order 
 *      given.
 */
bool CentralIO::_WeeklyCured(int week, int key){
    vector<FibNode*> print_list;
    
    // copy the list to be printed 
    print_list.assign(assignment->all_locations->cured_list[week].begin(),
    assignment->all_locations->cured_list[week].end());
    // sort the list
    sortByKey(print_list, key);
    // generate report using print_list (sorted)
    if (Write2File(print_list, week * 7, key) == false) exit(3);

    cout << "\nWeek " << week << "'s report (Cured patients ordered W.R.T key "<< key;
    cout << ") has been generated" << endl;
    return true;
}
bool CentralIO::_WeeklyAssigned(int week, int key){
    vector<FibNode*> print_list;

    // print_list 
    // TODO This needs further Verification
    print_list;

    
    cout << "\nWeek " << week << "'s report (Assigned patients ordered W.R.T key "<< key;
    cout << ") has been generated" << endl;
    return true;

    return true;
}
bool CentralIO::_WeeklyQueueing(int week, int key){
    vector<FibNode*> print_list;

    print_list.assign(heap->fiblist.begin(), heap->fiblist.end());

    sortByKey(print_list, key);

    if (Write2File(print_list, week * 7, key) == false) exit(3);

    cout << "\nWeek " << week << "'s report (Queueing patients ordered W.R.T key "<< key;
    cout << ") has been generated" << endl;
    return true;
}
bool CentralIO::_Monthly(int month, int key){
    /*
    string filename = "MonthlyStat_";
    filename += to_string(month) + ".md";

    ofstream out("output/"+filename);
    out << "# Central Queueing System Monthly Statistic Report | 2021, Month " << month << endl;
    out << "### Number of Treated People  " << endl;
    int num_treated = 0;
    for (int i = 0; i < int(assignment->all_locations->cured_list.size()); i++) {
        num_treated += assignment->all_locations->cured_list;
    }
    out << assignment->all_locations->cured_list.size() <<"  "<< endl;

    out << "### Number ";
    out.close();
    cout << "\nMonth " << month << "'s report has been generated." << endl;
    */
    return true;
}

/*
 * OUTPUT
 * 1. 0 (a >= b)
 * 2. 1 (a <  b)
 */
bool CentralIO::compare(FibNode* a, FibNode* b, int key)
{
    if (key == 0) {
        return (a->getname() < b->getname());
    } 
    if (key == 1) {
        return (a->getpro() < b->getpro());
    }
    if (key == 2) {
        return (a->getage() < b->getage());
    }
    return false;
}

void CentralIO::sortByKey(vector<FibNode*>&fiblist,int key)
{
    FibNode* temp;
    for (int i = 0; i < int(fiblist.size())-1; i++)
    {
        for (int j = 0; j < int(fiblist.size())-1-i; j++)
        {
            if (!this->compare(fiblist[j], fiblist[j+1], key))
            {
                temp=fiblist[j];
                fiblist[j]=fiblist[j+1];
                fiblist[j+1]=temp;
            }
        }
    }
}

#endif