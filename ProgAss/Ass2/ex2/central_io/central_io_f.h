#ifndef CENTRAL_IO_F
#define CENTRAL_IO_F

#include "central_io.h"
// #include <string>
using namespace std;
/* READ2HEAP
 * INPUT == NULL
 * OUTPUT == NULL
 * EFFECT
 * 1. It reads registrations from files generated by local registries, convert them into fibnodes and then insert all nodes into the fibheap
 * Algorithm Description
 * While inserting, it does the following things:
 * 1. Before insert, check if the ID is in hash table of the central heap (Check *withdrawn*, *centralheap*, *assigned*), if the id is not in hashtable, directly insert this node into the heap
 * if the node is in any of the three hash table, execute helper functions corresponding to the three cases.
 * 2. 
 * 3. 




/* Modified for CA2
 * After reading a record, it first insert it into the database, then insert a node into
 * the corresponding heap 
 */
bool CentralIO::Read2Heap(){
    // read all informations that needs to be inserted into 
    ifstream infile;
    infile.open(path, ifstream::in);

    // wait for information from local registries
    if (infile.eof()){
        infile.close();
        return false;
    }

    if (infile.fail()) { 
        cout << "File not found" <<endl; 
        return false;
    }
    vector<string> temp_list;
    string temp;
    string line;   
    getline(infile, line);  // remove the title of the CSV file
    while (true){
            getline(infile, line);
            
            // terminate the reading process on encountering an empty line
            if (int(line.size()) == 0) break; 
            
            // reading registrations from files generated from local registries
            for (int i = 0; i < int(line.size()); i++) {
                if (line.substr(i,1) == ",") {
                    // put this string into the vector
                    temp_list.push_back(temp);
                    // clear the temp string for the next argument
                    temp.clear();
                    continue;
                }
                if (line.substr(i,1) == "\r") {
                    continue;
                }
                temp.append(line.substr(i,1));
            }
            temp_list.push_back(temp);
        // clear this list for next use

        //check hash set

        // since priority rules can be simplified, we left out the original buggy code and 
        // do far less check than before. We think being able to Insert, Delete and Retrieve 
        // shall sufficiently show our ability to manipulate index structures

        // 建好各自的relation
        // leave the assigned part empty.
        registration Reg = registration(stoi(temp_list.at(0)),      // ID
                                    stoi(temp_list.at(4)),          // Registry ID
                                    stoi(temp_list.at(0)), -1,      // Person ID
                                    stoi(temp_list.at(9)),          // Treatment Type
                                    temp_list.at(8),                // Deadline
                                    temp_list.at(6),                // Registration Date
                                    stoi(temp_list.at(7)),          // Withdraw state
                                    false, -1, "Not Assigned", -1);

        person Per = person(stoi(temp_list.at(0)), 0,               // ID
                                    stoi(temp_list.at(1)),          // Risk ID
                                    stoi(temp_list.at(2)),          // Profession
                                    stoi(temp_list.at(3)),          // Age
                                    temp_list.at(10),               // Name
                                    temp_list.at(11),               // Email
                                    temp_list.at(13));              // Date of brith
        // no need to create medical status since we only need four
        // no need to create treatment since it is what assignment does
        FibNode* newnode = new FibNode(Reg);
        temp_list.clear();

        // 现在还是伪代码
        registration* node = Reg_Relation_Retrieve(Reg.getID());

        
        if (node) {
            if (node->getTreatmentID() != -1) {return true;}  // has been treated, nothing has to be done
            
            
            // do an update
            // FUCK it up
            Reg_Relation_Delete(Reg.getID());
            Reg_Relation_Insert(Reg);
            Per_Relation_Delete(Reg.getPersonID());
            Per_Relation_Insert(Per);
            if (Reg.getWithdraw() == 1){
                if (node->getAssignStatus()){
                    // TODO type check
                    // TODO　do the following things, remove it from assignment queue etc
                } else {
                    // TODO delete the node from heap, type check here!!!
                }
        }
            // the node is not in out database, insert corresponding things
    }
    Reg_Relation_Insert(Reg);
    Per_Relation_Insert(Per);
    if (Reg.getTreatmentType() == 0){
        vacc_heap->Insert(newnode);
    } else if (Reg.getTreatmentType() == 1){
        surg_heap->Insert(newnode);
    } else {
        regi_heap->Insert(newnode);
    }
    }
    return true;
}
/* CentralIO::Write2File
 * INPUT
 * 1. print_list -- a vector of registrations to be printed
 * 2. date       -- the date when a Write2File function is invoked (this affects the name of files)
 * 3. type       -- indicates the type of print (cured, assigned, waiting)
 * OUTPUT
 * 1. true/false -- whether the report generation has succeeded
 */

bool CentralIO::Write2File(vector<FibNode*>&print_list, int date, int type) {
    // string filename; // = "Report_";
    // // if (type == 3) {
    // //     filename += "Month_" + to_string(date / 30 + 1);
    // // } else {
    // //     filename += "Week_" + to_string(date / 7 + 1);
    // // }

    // switch (type) {
    //     case 0:
    //     filename = "Report_Week_" + to_string(date / 7) + "_Cured.csv";
    //     break;

    //     case 1:
    //     filename = "Report_Week_" + to_string(date / 7) + "_Assigned.csv";
    //     break;

    //     case 2:
    //     filename = "Report_Week_" + to_string(date / 7) + "_Waiting.csv";
    //     break;

    //     case 3:
    //     filename = "Report_Month_" + to_string(date / 30) + ".csv";

    //     default:
    //     cout << "You are fucked at CentralIO::Write2File" << date << type << endl;
    //     exit(3);
    // }   

    // ofstream out(filename, fstream::out);
    // if (!out) cout << "You are fucked" << endl;
    // out << "ProfessionCategory,AgeCategory,RiskStatus,WaitingTime" << '\r';
    // for (int i = 0; i < int(print_list.size()); i++) {
    //     out << print_list[i]->getpro();
    //     out << ",";
    //     out << print_list[i]->getage();
    //     out << ",";
    //     out << print_list[i]->getrisk();
    //     out << ",";
    //     if (type == 0)
    //         out << print_list[i]->getAppointment()->getDate() - print_list[i]->getdate() << endl;
    //     else
    //         out << date - print_list[i]->getdate();
    //     out << '\r';
    // }
    // out.close();
    return true;
}


/* TODO <=== Helper Function for Generating Reports ===> */
bool CentralIO::ReportWeekly(int week, int key){
    /* Generate Weekly Report for 
     * 1. People who have been treated including their profession, age category, risk status, and the waiting time from registration to treatment
     * 2. the registered people with a set appointment including their profession category, age category, risk status and their waiting time until now
     * 3. the queueing people without a set appointment including their profession category, age category, risk status and their waiting time until now
     */
    // _WeeklyCured(week, key - '0');
    // _WeeklyAssigned(week, key - '0');
    // _WeeklyQueueing(week, key - '0');
    return true;
}




bool CentralIO::ReportMonthly(int month, int key){
    // _Monthly(month, key - '0');
    return true;
}


/*
 * INPUT
 * OUTPUT
 * 1. Whether the report generation has succeed or not
 * EFFECT
 *      This function will take all information to be printed 
 *      from *assignment->all_locations->cured_list*. And call 
 *      CentralIO::sortByKey() to sort the vector w.r.t the order 
 *      given.
 */
bool CentralIO::_WeeklyCured(int week, int key){
    // vector<FibNode*> print_list;
    // // copy the list to be printed 
    // print_list.assign(assignment->all_locations->cured_list[week].begin(),
    // assignment->all_locations->cured_list[week].end());
    // // sort the list
    // sortByKey(print_list, key);
    // // generate report using print_list (sorted)
    // if (Write2File(print_list, week * 7, 0) == false) exit(3);

    // cout << "\nWeek " << week << "'s report (Cured patients ordered W.R.T key "<< key;
    // cout << ") has been generated" << endl;
    return true;
}
bool CentralIO::_WeeklyAssigned(int week, int key){
    // vector<FibNode*> print_list;

    // print_list 
    // TODO This needs further Verification
    // vector <FibNode*> print_list = heap->assigned_table->list_patient();

    // sortByKey(print_list, key);
    // if (Write2File(print_list, week * 7, 1) == false) exit(3);

    
    // cout << "\nWeek " << week << "'s report (Assigned patients ordered W.R.T key "<< key;
    // cout << ") has been generated" << endl;
    // return true;

    return true;
}
bool CentralIO::_WeeklyQueueing(int week, int key){
    // vector<FibNode*> print_list;
    // // generate fiblist
    // print_list.assign(heap->fiblist.begin(), heap->fiblist.end());
    // print_list.insert(print_list.end(), heap->highrisk_queue->fiblist.begin(), heap->highrisk_queue->fiblist.end());
    // sortByKey(print_list, key);

    // if (Write2File(print_list, week * 7, 2) == false) exit(3);

    // cout << "\nWeek " << week << "'s report (Queueing patients ordered W.R.T key "<< key;
    // cout << ") has been generated" << endl;
    return true;
}
bool CentralIO::_Monthly(int month, int key){
    
    // string filename = "MonthlyStat_";
    // filename += to_string(month) + ".md";

    // ofstream out(filename, fstream::out);
    // out << "# Central Queueing System Monthly Statistic Report | 2021, Month " << month << endl;
    
    // out << "### Number of Waiting People" << endl;
    // out << heap->GetNum() + heap->highrisk_queue->GetNum() << "  "<< endl;

    

    // out << "### Number of Treated People Per Month" << endl;
    // // int num_treated = 0;
    // // for (int i = 0; i < int(assignment->all_locations->cured_list.size()); i++) {
    // //     num_treated += assignment->all_locations->cured_list;
    // // }
    // int cured_nums = assignment->all_locations->cured_list[month*4 - 4].size() 
    //                + assignment->all_locations->cured_list[month*4 - 3].size()
    //                + assignment->all_locations->cured_list[month*4 - 2].size() 
    //                + assignment->all_locations->cured_list[month*4 - 1].size();
    // out << cured_nums << "  " << endl;

    // out << "### Average Waiting Time" << endl;
    // int avg_time = 0;
    // for (int k = 0; k < 4; k++){
    //     for (int i = 0; i < assignment->all_locations->cured_list[month*4 - k].size(); i++) {
    //         avg_time += assignment->all_locations->cured_list[month*4 - k][i]->getAppointment()->getDate() - 
    //         assignment->all_locations->cured_list[month*4 - k][i]->getdate();
    //     }
    // }
    // avg_time /= cured_nums;

    // out << avg_time << "days  " << endl;
    // ;

    // out << "### Number of People who withdrew their registration" << endl;
    // out << heap->withdraw_table->get_numitems() << "  " << endl;

    // out.close();
    // cout << "\nMonth " << month << "'s report has been generated." << endl;
    
    return true;
}

/*
 * OUTPUT
 * 1. 0 (a >= b)
 * 2. 1 (a <  b)
 */
bool CentralIO::compare(FibNode* a, FibNode* b, int key)
{
    // if (key == 0) {
    //     return (a->getname() < b->getname());
    // } 
    // if (key == 1) {
    //     return (a->getpro() < b->getpro());
    // }
    // if (key == 2) {
    //     return (a->getage() < b->getage());
    // }
    return false;
}

void CentralIO::sortByKey(vector<FibNode*>&fiblist,int key)
{
    // FibNode* temp;
    // for (int i = 0; i < int(fiblist.size())-1; i++)
    // {
    //     for (int j = 0; j < int(fiblist.size())-1-i; j++)
    //     {
    //         if (!this->compare(fiblist[j], fiblist[j+1], key))
    //         {
    //             temp=fiblist[j];
    //             fiblist[j]=fiblist[j+1];
    //             fiblist[j+1]=temp;
    //         }
    //     }
    // }
}

#endif